import re
from Bio.Seq import Seq
from Bio.Alphabet import generic_dna
from Bio import SeqIO
from optparse import OptionParser
import math


#Parse command line options
parser = OptionParser()
parser.add_option("-w", "--input", dest="wellId", action="store", help=".Well ID", metavar="STRING")
parser.add_option("-o", "--output", dest="outputTag", help="output file tag", metavar="STRING")
(options,args) = parser.parse_args()
revReadRegEx = re.compile('.*R.fq')
primerIds = ["2_4_F.fq","2_4_R.fq","2_2_F.fq","2_5_R.fq",]
wellId="/data/A04/MiSeq/%s/"%options.wellId
dnaRegEx = re.compile('^[ACGTN]+$')



def reverse_complement(read):
    seq = Seq(read, generic_dna)
    return seq.reverse_complement().tostring()    

#
#
# Sam Haldenby, 16 May 2012
# 
def rank2(finalCounts, recur):
    """Ranks genes based on number of each of the four reads that hit the gene
    
        For each read (2_2_F, 2_4_F, 2_5_R, 2_4_R), each hit gene will be ranked according to how many hits it received. For example, if 2_2_F hit the following genes in this pattern, they would be ranked as shown in column 3

        Gene        Count   Rank
        DRB1*01:01  120     1
        DRB1*03:02  10      3
        DRB1*03:04  10      3
        DRB1*04:01  5       4
        
        This is repeated for all reads and genes. Then, the score is calculated in two steps. Here is some example data to help
        
        Gene        Counts             Ranks
        DRB1*01:01  [120,10 ,500,0 ]   [1,2,1,4]
        DRB1*03:02  [10 ,0  ,100,0 ]   [3,4,2,4]
        DRB1*03:04  [10 ,100,50 ,35]   [3,1,3,1]
        DRB1*04:01  [5  ,0  ,0   4 ]   [4,4,4,2]
        
        Step 1: For each gene, the best count is divided by the worst rank, the second best count is divided by the second worst rank, etc 
        
        Gene        Counts             Ranks      Scores
        DRB1*01:01  [120,10 ,500,0 ]   [1,2,1,4]  [60  ,10  ,125 ,0 ] (i.e. 500/4, 120/2, 10/1, 0/1)
        DRB1*03:02  [10 ,0  ,100,0 ]   [3,4,2,4]  [2.5 ,0   ,25  ,0 ]
        DRB1*03:04  [10 ,100,50 ,35]   [3,1,3,1]  [10  ,33.3,16.7,35]
        DRB1*04:01  [5  ,0  ,0   4 ]   [4,4,4,2]  [1.25,0   ,0   ,2 ]
        
        The results are then summed
        Gene        Counts             Ranks      Scores               Sum
        DRB1*01:01  [120,10 ,500,0 ]   [1,2,1,4]  [60  ,10  ,125 ,0 ]  195
        DRB1*03:02  [10 ,0  ,100,0 ]   [3,4,2,4]  [2.5 ,0   ,25  ,0 ]  27.5
        DRB1*03:04  [10 ,100,50 ,35]   [3,1,3,1]  [10  ,33.3,16.7,35]  95
        DRB1*04:01  [5  ,0  ,0   4 ]   [4,4,4,2]  [1.25,0   ,0   ,2 ]  3.25
    
        Step 2: The scores are weighted if any reads reported no hits, i.e. score = score/(1+numberOfNoHits))
        Gene        Counts             Sum    NumNoHits  ModifiedScore
        DRB1*01:01  [120,10 ,500,0 ]   195    1          97.5
        DRB1*03:02  [10 ,0  ,100,0 ]   27.5   2          9.17
        DRB1*03:04  [10 ,100,50 ,35]   95     0          95
        DRB1*04:01  [5  ,0  ,0   4 ]   3.25   2          1.08
        
        So in this example, your best scorers are 01:01 and 03:04
        

        Args:
            finalCounts: A dict mapping keys as gene name and values as lists (size 4) containing the hit count for each read. CURRENTLY WORKS BEST IF 30 ENTRIES IN IT. This list is generated by rank()
            recur: Left over rubbish. Doesn't matter what you set it to
    
        Returns:
            Nothing yet, though it will eventually return the scores
    
        Raises:
            Nothing. It probably should though!
    """    
    

    
    
    #Manipulate data into 4 lists of dicts{geneName: countForThatRead}
    countsPerRead = [0] *4
    for readNum in range(0,4):
        #print readNum
        countsPerRead[readNum]={}
        for entry in finalCounts.items():
            name = entry[0]
            counts = entry[1]
            countsPerRead[readNum][name] = counts[readNum]
            #print readNum,countsPerRead[readNum][name]
        
        
    #now rank each gene based on number of reads mapping
    finalRanks = {}
    for readNum in range(0,4):

        #read through all readCounts in sorted order and assign a rank
        currRank =1
        prevScore = -1
        allSameScoreList = []
        rankDifferential = 0 
        for entry in sorted(countsPerRead[readNum], key=countsPerRead[readNum].get, reverse=True): 
            score = countsPerRead[readNum][entry]
            name = entry 
            if score != prevScore:
                currRank = currRank+rankDifferential+1      
                rankDifferential=1
                allSameScoreList = []
                allSameScoreList.append(name)
                #add rank
                if name not in finalRanks:
                    finalRanks[name] = [0]*4
                finalRanks[name][readNum]= currRank                
            else:
                #add rank
                rankDifferential+=1
                if name not in finalRanks:
                    finalRanks[name] = [0]*4
                finalRanks[name][readNum]= rankDifferential + currRank  
                allSameScoreList.append(name)
                for name in allSameScoreList:
                    finalRanks[name][readNum]=rankDifferential + currRank
            prevScore = score

            
    #calculate raw score
    overallRanks = {}
    for entry in finalRanks.items():
        #print entry
        name = entry[0]
        rankings = entry[1]
        overallRanks[name] = sum(rankings)
    
    newScoreMap = {}
    for entry in sorted(overallRanks, key=overallRanks.get, reverse=True):
        name = entry
        rank = overallRanks[entry]
        individualRanks = finalRanks[name]
        originalCounts = finalCounts[name]

        
        #new ranking idea multiply highest count by worst rank.....lowest count by best rank
        orderedRanks=[]
        orderedCounts=[]
        for i in sorted(individualRanks):
            orderedRanks.append(i)
        for i in sorted(originalCounts):
            orderedCounts.append(i)
        misses =0
        newIdeaScore = 0.0
        for i in range(0,4):
            if orderedCounts[i]>0:
                newIdeaScore+=orderedCounts[i]/orderedRanks[i]
            else:
                misses+=1
            
        newIdeaScore = newIdeaScore/(1+misses)
        
       
        calibratedScore = 0
        missModifier = 1.0        
        for i in range(0,4):
            calibratedScore+=originalCounts[i]/individualRanks[i]
            if originalCounts[i]==0:
                missModifier-=0.25
                misses+=1
                
        newIdeaScore = newIdeaScore/(1+misses)
        calibratedScore = calibratedScore / missModifier
        newScoreMap[name]=newIdeaScore
    #    print "size",len(newScoreMap), name, newIdeaScore, newScoreMap[name]
        #add to map based on newIdeaScore
        
        print name,"\t",individualRanks,"\t",originalCounts,"\t", rank,"\t", sum(originalCounts)/rank,"\t", calibratedScore,"\t", newIdeaScore
    
    top10 =0
   # for entry in newScoreMap.items():
      #  print "@",entry
    #for entry in sorted(finalScores, key=finalScores.get, reverse=True):
    for entry in sorted(newScoreMap, key=newScoreMap.get, reverse=True):
      #  print "ENTRY:",entry, len(newScoreMap)
        name = entry
        score = newScoreMap[entry]
        
        if top10 < 10:
            print name,finalRanks[name],finalCounts[name],score
        top10+=1
            
    
    #translate back to score map i.e. (name,[1][10][13][1])
#    for entry in finalRanks.items():
#        print entry[0],entry[1]
            


def rank(finalCounts, recur):
    readTotals = [0]*4
    counter=0
    for entry in finalCounts.items():
#        print entry
        for x in range (0,4):
            readTotals[x]+=entry[1][x]
    
#    print "ReadTotals:%s" % readTotals
    
    overallTotals = sum(readTotals)
    readProportions = [0.0]*4
    for x in range(0,4):
        readProportions[x] = readTotals[x]/float(overallTotals)
#    print "ReadProps :%s" % readProportions
    
    #now, calculate all scores
    finalScores = {}
    for entry in finalCounts.items():
        noHits=0
        name = entry[0]
        counts = entry[1]
        normalisedCounts = [0.0]*4
        totalForTarget = sum(counts)
        for x in range(0,4):
            if counts[x]==0:
        #        print "NOHITS:",name,noHits
                noHits+=1
            if totalForTarget!=0 and readProportions[x]>0.0001:
                normalisedCounts[x] = counts[x]/(totalForTarget*readProportions[x])
         #   print x,normalisedCounts[x]
            if normalisedCounts[x] > 1.0:
                normalisedCounts[x] = 1.0
       
        multipliedScore = (normalisedCounts[0]+0.01) * (normalisedCounts[1]+0.01) * (normalisedCounts[2]+0.01) * (normalisedCounts[3]+0.01)
        finalScore = 0
        if totalForTarget!=0:
            finalScore = pow(multipliedScore,(1.0/float(totalForTarget)))
        
        #normalise based on missing read mappings
        readMissingNormaliser = 1 / (1+ pow(noHits,0.1)/1000)
        
        finalScores[name]=finalScore * readMissingNormaliser# float(1.0/(1.0+((noHits*noHits)/100.0))) #float(1.0/(1+(noHits/10.0)))
        #TODO: This may elimiate otherwise good candidates - therefore MUST have a warning system in place - if the score is high but gets demoted due to a read not mapping to it, MUST report it's pre-calibration score too!
       # print name, finalScore, finalScore* float(1.0/(1.0+((noHits*noHits)/100.0)))
    
   
    #only bother printing out if this is the last recurrance of rank
    if recur==False:
        top10=0
        print
        print "SCORES",recur
        
        for entry in sorted(finalScores, key=finalScores.get, reverse=True):
                score = finalScores[entry]
                name = entry
                #tallies = counts
                tallies = finalCounts[name]
                if top10 < 10:
                    print name,tallies, score  
                top10+=1                
  
    #rebuild a suitable construct to send back to this function - this will recalibrate based only on the top 10 results
    RECAL_BASED_ON = 30
    if recur == True:
        top10=0
        recalMap = {}
        for entry in sorted(finalScores, key=finalScores.get, reverse=True):    
            score = finalScores[entry]
            name = entry
            tallies = finalCounts[name]
            if top10 < RECAL_BASED_ON:
                recalMap[name]=tallies
            top10+=1
        
        rank2(recalMap,False)
        rank(recalMap,False)
        
    
    
    #return top 10
    top10=0
    returnMap = {}
    for entry in sorted(finalScores, key=finalScores.get, reverse=True):    
        score = finalScores[entry]
        name = entry
        if top10 < 300000:
            returnMap[name]=score
        top10+=1    
    
    return returnMap
        
                         
                        
            

countsDict = {}
countsDict["2_2_F.fq"]={}
countsDict["2_4_F.fq"]={}
countsDict["2_4_R.fq"]={}
countsDict["2_5_R.fq"]={}

#load all ref seqs into memory
refs = {}
antiRefs = {}
drb1RegEx = re.compile('DRB1')
refFile = open("subject.txt")
for line in refFile:
    line = line.strip()
    
    lineSpl = line.split("\t")
    if len(lineSpl) ==2:
        if drb1RegEx.match(line):
            refs[lineSpl[0]] = lineSpl[1]
        else:
            antiRefs[lineSpl[0]] = lineSpl[1]   

refFile.close()

for p in primerIds:
    currCounts = {}
    readCount =0
    hits =0
    #change behaviour based on which read it is
    if p== "2_2_F.fq": #0:160
        reverse = False
        startPos = 0
        endPos = 160
    elif p== "2_4_F.fq":#0:150
        startPos = 0
        endPos = 150
        reverse = False
    elif p=="2_4_R.fq":#33:200
        startPos = 33
        endPos = 200#250
        reverse = False
    elif p=="2_5_R.fq": #70:232
        startPos = 70
        endPos = 232
        reverse = False   
       
       
    queryFile = open("%s%s"%(wellId,p))
    outFile = open("%s_results.txt"%(p),"w")
    hitFrequency=[0]*51
    for line in queryFile:
        if dnaRegEx.match(line):  
            query= line[startPos:endPos]
            if reverse == True:
                query = reverse_complement(query)
           
            readCount+=1
            presentInAntiRef = False
            for aRef in antiRefs.items():
                aName = aRef[0]
                aSeq = aRef[1]
                if query in aSeq:
                    #print "Found in %s"%aName
                    presentInAntiRef = True
                    
                    for ref in refs.items():
                        name = ref[0]
                        seq = ref[1]
                      #  print name,seq
                    #    if query in seq:   
                    #        print "Found in %s and %s"%(aName,name)
                    break
            hitsForThisRead=0
            ambiguityScore=0.0
            if presentInAntiRef == False:
                #print query
                #calculate weighting for this read based on ambiguity
                for ref in refs.items():
                    name = ref[0]
                    seq = ref[1]
                    if query in seq:
                        ambiguityScore+=1.0
                for ref in refs.items():
                    name = ref[0]
                    seq = ref[1]
                   # print name,seq
                    if query in seq:
                      #  print "\t",name
                        if name not in currCounts:
#                            currCounts[name] = (1.0/ambiguityScore)
                            currCounts[name]=1
                        else:
                            currCounts[name] +=(1.0/math.log(ambiguityScore+1,10))
                        hits+=1
                        hitsForThisRead+=1
           # print hitsForThisRead
            if hitsForThisRead<50:
                hitFrequency[hitsForThisRead]+=1
            else:
                hitFrequency[50]+=1
    print p,startPos, endPos, len(currCounts), hits, hitFrequency
    outFile.close()
    queryFile.close()
    
    countsDict[p]=currCounts
#raw_input("Done....")
    
#print currCounts


#now create counts based on only first 2 fields of name
for p in primerIds:
    shorterCounts = {}
    for hit in countsDict[p].items():
        colonSpl = hit[0].split(":")
        shorterName = "%s:%s"%(colonSpl[0],colonSpl[1])    
        if shorterName not in shorterCounts:
            shorterCounts[shorterName]=hit[1]
        else:
            shorterCounts[shorterName]+=hit[1]
    countsDict[p]=shorterCounts
        
#compare counts
#add all detected hlas to a set
allHits = set()
for p in primerIds:
    for hit in countsDict[p].items():
        allHits.add(hit[0])
        
#print "ALL HITS: %s"%allHits

# now do counts per hit across samples present in all 

#print
#print
finalMap = {}
success = False
for commonHit in allHits:
    
    finalMap[commonHit]=[0]*4
    currSample = 0
    for p in primerIds:
        if commonHit in countsDict[p]:
            finalMap[commonHit][currSample] = countsDict[p][commonHit]
          #  print commonHit, countsDict[p][commonHit]
        currSample+=1
#    
#    
#    
#    if 0 not in finalMap[commonHit]:
#        success = True
#        print "%s\t%d\t%d\t%d\t%d\t%d"%(commonHit,finalMap[commonHit][0],finalMap[commonHit][1],finalMap[commonHit][2],finalMap[commonHit][3],sum(finalMap[commonHit]))

#if success == False:
#    for entry in finalMap.items():
#        commonHit = entry[0]
#        zeroCount=0
#        for c in finalMap[commonHit]:
#            if c==0:
#                zeroCount+=1
#        if zeroCount <=2:
#            print "%s\t%d\t%d\t%d\t%d\t%d"%(commonHit,finalMap[commonHit][0],finalMap[commonHit][1],finalMap[commonHit][2],finalMap[commonHit][3],sum(finalMap[commonHit]))


finalScores = rank(finalMap, True)

#remap(finalScores,refs)


        
    